int Socket(int domain, int type, int protocol) 	Создать новый сокет и вернуть файловый дескриптор

1)domain указывающий семейство протоколов создаваемого сокета
AF_INET для сетевого протокола IPv4
AF_INET6 для IPv6
AF_UNIX для локальных сокетов (используя файл)
2)type
SOCK_STREAM (надёжная потокоориентированная служба (сервис) или потоковый сокет)
SOCK_DGRAM (служба датаграмм или датаграммный сокет)
SOCK_RAW (Сырой сокет — сырой протокол поверх сетевого уровня).
3)protocol(IPPROTO_TCP или IPPROTO_UDP)
0 - для выбора системой

void Bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) Связать сокет с IP-адресом и портом

1)sockfd — дескриптор, представляющий сокет при привязке
2)serv_addr — указатель на структуру sockaddr, представляющую адрес, к которому привязываем.
3)addrlen — поле socklen_t, представляющее длину структуры sockaddr.

void Getsockname(int sockfd, struct sockaddr *addr, socklen_t *len) Нахождение свободного порта

void Listen(int sockfd, int backlog) Объявить о желании принимать соединения. Слушает порт и ждет когда будет установлено соединение

int Accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) Принять запрос на установку соединения

1)sockfd — дескриптор слушающего сокета на принятие соединения.
2)cliaddr — указатель на структуру sockaddr, для принятия информации об адресе клиента.
3)addrlen — указатель на socklen_t, определяющее размер структуры, содержащей клиентский адрес и переданной в accept(). Когда accept() возвращает некоторое значение, socklen_t указывает сколько байт структуры cliaddr использовано в данный момент.

void Connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) Установить соединение

int send ( int sid, const char* buf, int len, int flag) Отправить данные по сети
int sendto (int sid, const char* buf, int len, int flag, struct sockaddr* addr_p, int* len_p )

int recv ( int sid, char* buf, int len, int flag ) Получить данные из сети
int recvfrom ( int sid, const char* buf, int len, int flag, struct sockaddr* addr_p, int* len_p )

int inet_aton(const char *strptr, struct in_addr *addrptr);
Функция преобразует строку, на которую указывает strptr, в 32-разрядное
двоичное число (например, 172.103.15.189), записанное в сетевом порядке байтов,
передаваемое через указатель addrptr. В случае успешного выполнения
возвращаемое значение равно 1, иначе возвращается нуль

in_addr_t inet_addr(const char *strptr);
Функция выполняет такое же преобразование, что и inet_aton, возвращая в
качестве значения 32-разрядное двоичное число в сетевом порядке байтов.

char *inet_ntoa(struct in_addr inaddr);
является обратной к вышеописанным
возвращает: указатель на строку с адресом в точечно-десятичной записи.

int inet_pton(int af, const char *src, void *dst);
Данная функция преобразует строку символов src в сетевой адрес (типа af), затем
копирует полученную структуру с адресом в dst.

const char *inet_ntop(int af, const void *src, char *dst, size_t cnt); 
Данная функция преобразует структуру сетевого адреса src в строку символов с
сетевым адресом (типа af), которая затем копируется в символьный буфер dst; 
размер этого буфера составляет cnt байтов. inet_ntop возвращает ненулевой указатель на dst.

IP-адрес (Internet Protocol Address) — это уникальный сетевой адрес узла 
в компьютерной сети, построенной по протоколу IP. В сети Интернет требуется глобальная уникальность адреса 
в случае работы в локальной сети требуется уникальность адреса в пределах сети. 
В версии протокола IPv4 IP-адрес имеет длину 4 байта, в IPv6 — 16 байт.

Номер порта является 16-разрядным целым двоичным числом, таким образом, 
порты возможны в диапазоне от 1 до 65535 (для TCP, номер порта 0 зарезервирован и не может быть использован).
Для UDP порт источника не является обязательным и нулевое значение означает отсутствие порта.

Для обеспечения сетевых коммуникаций используются сокеты. Сокет это конечная точка сетевых коммуникаций. 
Каждый использующийся сокет имеет тип и ассоциированный с ним процесс.
Сокеты существуют внутри коммуникационных доменов. Домены это абстракции, которые подразумевают конкретную структуру адресации и множество протоколов,
которое определяет различные типы сокетов внутри домена. Примерами коммуникационных доменов могут быть: UNIX домен, Internet домен, и т.д.
Обычно клиент явно подсоединяется к слушателю, после чего любое чтение или запись через его файловый дескриптор будут передавать данные между ним и сервером.

Ко всем потокам ввода-вывода (которые могут быть связаны как с файлами, так и с каталогами, сокетами и FIFO) 
можно получить доступ через так называемые файловые дескрипторы. Файловый дескриптор — это неотрицательное целое число. 
Когда создается новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.

O_CREAT - если файл не существует, то он будет создан.
S_IRWXU - пользователь (владелец файла) имеет права на чтение, запись и выполнение файла
O_EXCL - если он используется совместно с O_CREAT, то при наличии уже созданного файла вызов open завершится с ошибкой.
O_TRUNC - если файл уже существует, он является обычным файлом и режим позволяет записывать в этот файл 
(т.е. установлено O_RDWR или O_WRONLY), то его длина будет урезана до нуля.

pthread_t — идентификатор потока;
pthread_mutex_t — мютекс;
pthread_mutexattr_t — объект атрибутов мютекса
pthread_cond_t — условная переменная
pthread_condattr_t — объект атрибута условной переменной;
pthread_key_t — данные, специфичные для потока;
pthread_once_t — контекст контроля динамической инициализации;
pthread_attr_t — перечень атрибутов потока.

Мьютексы — это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном 
или неотмеченном (открыт и закрыт соответственно). Задача мьютекса — защита объекта от доступа к нему других потоков, 
отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. 
Если другому потоку будет нужен доступ к переменной, защищённой мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

Цель использования мьютексов — защита данных от повреждения в результате асинхронных изменений (состояние гонки), однако могут порождаться другие проблемы (например взаимные блокировки).

Функция pthread_mutex_lock(), если mutex еще не занят, то занимает его, становится его обладателем и сразу же выходит. 
Если мьютекс занят, то блокирует дальнейшее выполнение процесса и ждет освобождения мьютекса.

Коды возврата для pthread_mutex_lock():
EINVAL — mutex неправильно инициализирован
EDEADLK — мьютекс уже занят текущим процессом

Функция pthread_mutex_trylock() идентична по поведению функции pthread_mutex_lock(), с одним исключением — она не блокирует процесс, если mutex занят, а возвращает EBUSY код.

Коды возврата для pthread_mutex_trylock():
EBUSY — мьютекс уже занят
EINVAL — мьютекс неправильно инициализирован

Фунция pthread_mutex_unlock() освобождает занятый мьютекс.

Коды возврата для pthread_mutex_unlock():
EINVAL — мьютекс неправильно инициализирован
EPERM — вызывающий процесс не является обладателем мьютекса

Макрос PTHREAD_MUTEX_INITIALIZER инициализирует статический mutex mutex, устанавливая для его атрибутов значения по умолчанию.

Новый поток создается функцией pthread_create()

1)Первый параметр вызова pthread_create() является адресом для хранения идентификатора создаваемого потока типа pthread_t.
2)Аргумент start является указателем на потоковую void * функцию, принимающей бестиповый указатель в качестве единственной переменной.
3)Аргумент arg — это бестиповый указатель, содержащий аргументы потока. 
Чаще всего arg указывает на глобальную или динамическую переменную, но если вызываемая функция не требует наличия аргументов, то в качестве arg можно указать NULL.
4)Аргумент attr также является бестиповым указателем атрибутов потока pthread_attr_t. Если этот аргумент равен NULL, то поток создается с атрибутами по умолчанию.

В случае усспеха возвращает 0.
